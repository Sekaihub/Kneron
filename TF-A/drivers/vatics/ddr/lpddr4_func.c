#include "kdrv.h"
#include "dmac.h"
#include "sim_print.h"
#include "lpddr4.h"

#include <common/debug.h>
#include <platform_def.h>

// #define LOOP

void pub_save(void);
void pub_restore(void);
void skiptrain_save(void);
void skiptrain_restore(void);

static void retention_entry(void);
static void retention_exit(void);

struct __WAGNER_SIM_FUNC__ {
	struct __CHIP__ {
		struct __CORE__ {
			struct __PMU_Core__ {
				void (*pmu_o_clampz)(int);
			}PMU_Core;
		}Core;
	}Chip;
}WAGNER_SIM_FUNC;

void reenable_power(void) {
  unsigned int data;
  unsigned int *debug_reenbale_power = (unsigned int *)(unsigned long)0xce200004;

// WAGNER_SIM_FUNC.Chip.Core.PMU_Core.pmu_o_clampz = clampz;
 // page 286

  *debug_reenbale_power = 1;
  // step1 .  Enable power and reset controller/PHY ;     reset can controlled by FW


  //`include "suspend_power_up.pat";
  //force WAGNER_SIM_FUNC.Chip.Core.DDRNSDMC_I_PWR_VDDA_1P8 = 1;
  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  //force WAGNER_SIM_FUNC.Chip.Core.VDDC = 1;
  // release WAGNER_SIM_FUNC.sys_osc_fbclk;
  // force WAGNER_SIM_FUNC.sys_rstz_r = 0;
  // for ( i = 0; i < 100; i++) asm volatile("nop\n\t");
  // force WAGNER_SIM_FUNC.sys_rstz_r = 1;
  // for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  //@(posedge WAGNER_SIM_FUNC.Chip.Core.PLLC_Core.pllc_o_pll_1_lock);
  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x00100004); //stop PHY apb and PHY
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00400010); //PHY apb reset and PHY reset
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x00100004); //stop PHY apb and PHY
  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  mwl((SYSC_SECURE_MMR_BASE+0x00000180), 0xFFFFFFFF);
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0xFFFFFFFF);
  mwl((SYSC_SECURE_MMR_BASE+0x00000190), 0xFFFFFFFF);
  mwl((SYSC_SECURE_MMR_BASE+0x00000198), 0xFFFFFFFF);
  mwl((SYSC_SECURE_MMR_BASE+0x000001A0), 0xFFFFFFFF);
  mwl((SYSC_SECURE_MMR_BASE+0x000001A8), 0xFFFFFFFF);
  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
//  mwl((SYSC_SECURE_MMR_BASE+0x00000158), 0xFFFFFFFF);
//  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0xFFFFFFFF);
//  mwl((SYSC_SECURE_MMR_BASE+0x00000168), 0xFFFFFFFF);
//  mwl((SYSC_SECURE_MMR_BASE+0x00000170), 0xFFFFFFFF);
//  mwl((SYSC_SECURE_MMR_BASE+0x00000178), 0xFFFFFFFF);

   mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x001FFFFF);   //stop ddrnsdmc clk
   mrl((PLLC_MMR_BASE + 0x0000000c), data);
   mwl((PLLC_MMR_BASE+ 0x0000000c), ( (data&0xF000FFFF) | 0x3C0000));  // update 1.2G
   //mwl((PLLC_MMR_BASE+ 0x0000000c), ( (data&0xF000FFFF) | 0x500000));  // update 1.6G
   mrl((PLLC_MMR_BASE + 0x00000004), data);
   mwl((PLLC_MMR_BASE+ 0x00000004), (data | 0x1));   // update configuration



  mrl((PLLC_MMR_BASE + 0x00000004), data);
   while ((data&0x00000001)!=0x00000000)
   {
       mrl((PLLC_MMR_BASE+0x00000004), data);
   }

  mrl((PLLC_MMR_BASE + 0x00000008), data);
   while ((data&0x00000003)!=0x00000003)
   {
       mrl((PLLC_MMR_BASE+0x00000008), data);
   }
   mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x001FFFFF);   // enable ddrnsdmc clk

//  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00400000);	    // pub_apb[22], set to '1'

  mwl((SYSC_SECURE_MMR_BASE+0x00000164), 0x00400010); //PHY apb reset and PHY reset

// Enable PHY and PUB clock in APM
//mrl(DDRNSDMC_APM_MMR_BASE + 0x00000464, data );
//mwl(DDRNSDMC_APM_MMR_BASE + 0x00000464, data|0x0FFFF0,  2);

  // reenable other power mctl2 


  /*** phy por : Figure 6-16***/
 // VDD/VAA -> DFICLK -> PRESET/RESET (assert)   -> PwrOkIn -> 
 //                      PRESET/RESET (deassert) -> dfi_reset_n -> dfi_init_start

 
  //for ( i = 0; i < 20; i++) asm volatile("nop\n\t"); // just for simulation

/*
  force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_ddr_umctl2.core_ddrc_rstn = 0;
  for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_ddr_umctl2.presetn = 1'b0;  
  for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
*/


  // core ddrc resetn = 0   ddrc and phy presetn = 0
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ), data & 4'b1000 ,  2); 


  mwl((SYSC_SECURE_MMR_BASE+0x00000164), 0x0060000F);	    // pub_apb[22], mcctrl2_apb[21], core ddrc resetn[3] set to '0'


  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");    
  // core ddrc phy_reset = 1
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ), data | 4'b1000 ,  2); 


  mwl((SYSC_SECURE_MMR_BASE+0x00000164), 0x10);	 //mmr pub Reset [3] to '0' , to real PHY Reset is '1'

  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");    

mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00800000);  // release DDRNSDMC power OK

/*
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data | 0x00001f00 | 0x20); 

  debug_remove_power = 11;
  //step11   [0] polls DFISTAT.dfi_init_complete=0
  mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
*/



//  force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_DDRPHY0_top.PwrOkIn = 1;
//    mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_PWROKIN) *4 )  , 1,2); 

//  force WAGNER_SIM_FUNC.Chip.Core.DDRNSDMC_Core.ddrnsdmc_i_ext_pwr_ok = 1;

//display("Set CPZ to 1'b1..."); // Use PMU to set clampz = 1;
//Read_Shift_Register("Read CONFIG register", 2, 4'b1110, data);
//#2us;
//Write_Shift_Register("Write CONFIG register", 2, 4'b1110, data|0x00040000);
//#2us;   //  PUB pwr_ok [23] = 0
//
//display("Set EAON and ECA to 1'b1...");
//Read_Shift_Register("Read CONFIG register", 2, 4'b1110, data);
//#2us;
//Write_Shift_Register("Write CONFIG register", 2, 4'b1110, data&0xFFF5FFFF);

//  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00800000);	 //PUB pwr_ok [23] = 1
    //WAGNER_SIM_FUNC.Chip.Core.PMU_Core.pmu_o_clampz(1); 

  //for ( i = 0; i < 30; i++) asm volatile("nop\n\t");


 
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data | 4'b0100 ,  2);  // phy presetn = 1

  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x00100007); //stop phy presetn
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00400007);	  //phy presetn [22] = 1    
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x00100007); // start phy presetn


  //for ( i = 0; i < 30; i++) asm volatile("nop\n\t");
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data & 0xfffffff7 ,  2);  // phy reset = 0


  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x00000004); //stop pub reset
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00000010);	//mmr pub Reset [4] to '1' , to real PHY Reset is '0'
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x00000004); // start pub reset


  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
//  for (int k=0; k <16 ;k++)
//    test.aresetn[k] = 0;
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data & 200x0000f ,  2); 


  mwl((SYSC_SECURE_MMR_BASE+0x00000164), 0x001FFFE0);	//axi resetn [20:5] = 0



  *debug_reenbale_power = 2;
  // step2 . Re-enable clocks if clocks were disabled after power removal
  
  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  *debug_reenbale_power = 3;
  // step3 . Remove APB reset, presetn = 1?�b1, and re-reprogram the registers to pre-power removal values  
  //force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_ddr_umctl2.presetn = 1'b1;  

//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data | 4'b0010 ,  2);  // ddrc  presetn = 1


  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x00080000); //stop apb reset
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00200000);	   //mctrl apb reset [21] = '1'
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x00080000); // start apb reset


  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");

  initial_pre_lp3();

  mwl(DDR3_TOP_CTRL_BASE+ SWCTL, 0x0);//Set mwl_done = 0 

  *debug_reenbale_power = 4;
  // step4     [31:30] skip_dram_init == 'b11
  mrl(DDR3_TOP_CTRL_BASE + INIT0,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ INIT0,  data | 0xc0000000);


  *debug_reenbale_power = 5;
  // step5  Programs ????to bit[5] PWRCTL.selfref_mwl
  mrl(DDR3_TOP_CTRL_BASE + PWRCTL,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ PWRCTL,  data | 0x20);

  *debug_reenbale_power = 6;


  // step6  Program  bit[0] DFIMISC.dfi_init_complete_en to 1?�b0
  mrl(DDR3_TOP_CTRL_BASE + DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data & 0xfffffffe);

  *debug_reenbale_power = 7;
  // step7  Remove the controller reset core_ddrc_rstn = 1?�b1 aresetn_n = 1?�b1
//  test.ddrc_if.core_ddrc_rstn = 1; 
//  force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_ddr_umctl2.core_ddrc_rstn = 1;

//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data | 4'b0001 ,  2);  // ddrc core resetn = 1


  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x00000004); //stop mctl core reset
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x00000008);	 //mctrl core reset [3] = 1
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x00000004); // start mctl core reset


  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
//  for (int k=0; k <16 ;k++)
//    test.aresetn[k] = 1;
//  mrl(DDRNSDMC_APM_MMR_BASE + ( ((17 << 4) +  DDRC_RSTN_CTRL) *4 ) , data );
//  mwl(DDRNSDMC_APM_MMR_BASE  +  (( (17 << 4) + DDRC_RSTN_CTRL) *4 )  , data | 200xffff0 ,  2);  // all aresetn = 1



  mwl((SYSC_SECURE_MMR_BASE+0x0000018C), 0x0007FFFC); //stop axi resetn [20:5]
  mwl((SYSC_SECURE_MMR_BASE+0x00000160), 0x001FFFE0);	//axi resetn [20:5] = 0xffff
  mwl((SYSC_SECURE_MMR_BASE+0x00000188), 0x0007FFFC); // start axi resetn [20:5]



  //for ( i = 0; i < 10; i++) asm volatile("nop\n\t");
  *debug_reenbale_power = 8;
  // step8 Run PHY initialization/training as required, including removing the IOs from retention
  //        mode, including steps below  
  

  retention_exit();

  *debug_reenbale_power = 9;

  // step9   [12:8]DFIMISC.dfi_frequency  = 0   
  mrl (DDR3_TOP_CTRL_BASE+ DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  (data & 0xffffe0ff) );

  *debug_reenbale_power = 10;
  //step10   [5] dfi_init_start  =1
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  (data & 0xffffe0ff) | 0x20);

  *debug_reenbale_power = 11;
  //step11   [0] polls DFISTAT.dfi_init_complete=1
  mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  while ((data & 1) == 0) {
    mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  }

  *debug_reenbale_power = 12;
  //step12   [5] dfi_init_start  =0
  mrl (DDR3_TOP_CTRL_BASE+ DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  (data & 0xffffffdf));

  *debug_reenbale_power = 13;
  // step13  Program  bit[0] DFIMISC.dfi_init_complete_en to 1?�b1
  mrl(DDR3_TOP_CTRL_BASE + DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data | 0x1);

  *debug_reenbale_power = 14;
  //step14 Write ????to bit[5] PWRCTL.selfref_mwl 
  mrl(DDR3_TOP_CTRL_BASE + PWRCTL,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ PWRCTL, data & 0xffffffdf);

  *debug_reenbale_power = 15;
  //step15  wait  bit[5:4] selfref_type == 0

  mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  while (((data >> 4) & 3)  != 0x0) {
    mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  }

  *debug_reenbale_power = 16;
  //step16  wait [2:0] STAT.operating_mode = 1
  mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  while (((data >> 0) & 7)  != 1) {
    mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  }

  *debug_reenbale_power = 17;
  // step17 Restore value bit[8] DFILPCF0.dfi_lp_en_sr prior to self-refresh entry
  mrl(DDR3_TOP_CTRL_BASE  + DFILPCFG0,  data);
  mwl(DDR3_TOP_CTRL_BASE+ DFILPCFG0,  ((*(unsigned int *)VPL_RET_RAM_BASE) & 0x100) ? data | 0x100
                                                     : data & 0xfffffeff);

  *debug_reenbale_power = 18;
  //step18   PCTRL_n.port_en = 1
  for(int i = 0; i <16; i++)
    mwl(DDR3_TOP_CTRL_BASE+ PCTRL_0 + 0xb0 * i, 1);
   
  mwl(DDR3_TOP_CTRL_BASE+ SWCTL, 0x1);//Set mwl_done = 1
}

#ifdef LOOP
const unsigned int pub_phy_fw_addr[] = {
	DDRNSDMC_PUB_MMR_BASE + (2*0x1005f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1015f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1105f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1115f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1205f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1215f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1305f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1315f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11005f),	DDRNSDMC_PUB_MMR_BASE + (2*0x11015f),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11105f),	DDRNSDMC_PUB_MMR_BASE + (2*0x11115f),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11205f),	DDRNSDMC_PUB_MMR_BASE + (2*0x11215f),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11305f),	DDRNSDMC_PUB_MMR_BASE + (2*0x11315f),
	DDRNSDMC_PUB_MMR_BASE + (2*0x55),  	DDRNSDMC_PUB_MMR_BASE + (2*0x1055),  
	DDRNSDMC_PUB_MMR_BASE + (2*0x2055),  	DDRNSDMC_PUB_MMR_BASE + (2*0x200c5), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1200c5),	DDRNSDMC_PUB_MMR_BASE + (2*0x2002e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12002e),	DDRNSDMC_PUB_MMR_BASE + (2*0x90204), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x190204),	DDRNSDMC_PUB_MMR_BASE + (2*0x20024), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x2003a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x2007d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x2007c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120024),
	DDRNSDMC_PUB_MMR_BASE + (2*0x12007d),	DDRNSDMC_PUB_MMR_BASE + (2*0x12007c),
	DDRNSDMC_PUB_MMR_BASE + (2*0x20056), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120056),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1004d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1014d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1104d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1114d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1204d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1214d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1304d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1314d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11004d),	DDRNSDMC_PUB_MMR_BASE + (2*0x11014d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11104d),	DDRNSDMC_PUB_MMR_BASE + (2*0x11114d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11204d),	DDRNSDMC_PUB_MMR_BASE + (2*0x11214d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11304d),	DDRNSDMC_PUB_MMR_BASE + (2*0x11314d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x10049), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10149), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11049), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11149), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12049), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12149), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13049), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13149), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110049),	DDRNSDMC_PUB_MMR_BASE + (2*0x110149),
	DDRNSDMC_PUB_MMR_BASE + (2*0x111049),	DDRNSDMC_PUB_MMR_BASE + (2*0x111149),
	DDRNSDMC_PUB_MMR_BASE + (2*0x112049),	DDRNSDMC_PUB_MMR_BASE + (2*0x112149),
	DDRNSDMC_PUB_MMR_BASE + (2*0x113049),	DDRNSDMC_PUB_MMR_BASE + (2*0x113149),
	DDRNSDMC_PUB_MMR_BASE + (2*0x43),  	DDRNSDMC_PUB_MMR_BASE + (2*0x1043),  
	DDRNSDMC_PUB_MMR_BASE + (2*0x2043),  	DDRNSDMC_PUB_MMR_BASE + (2*0x20018), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x20075), 	DDRNSDMC_PUB_MMR_BASE + (2*0x20050), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x20008), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120008),
	DDRNSDMC_PUB_MMR_BASE + (2*0x20088), 	DDRNSDMC_PUB_MMR_BASE + (2*0x200b2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10043), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10143), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11043), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11143), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12043), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12143), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13043), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13143), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1200b2),	DDRNSDMC_PUB_MMR_BASE + (2*0x110043),
	DDRNSDMC_PUB_MMR_BASE + (2*0x110143),	DDRNSDMC_PUB_MMR_BASE + (2*0x111043),
	DDRNSDMC_PUB_MMR_BASE + (2*0x111143),	DDRNSDMC_PUB_MMR_BASE + (2*0x112043),
	DDRNSDMC_PUB_MMR_BASE + (2*0x112143),	DDRNSDMC_PUB_MMR_BASE + (2*0x113043),
	DDRNSDMC_PUB_MMR_BASE + (2*0x113143),	DDRNSDMC_PUB_MMR_BASE + (2*0x200fa), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1200fa),	DDRNSDMC_PUB_MMR_BASE + (2*0x20019), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120019),	DDRNSDMC_PUB_MMR_BASE + (2*0x200f0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x200f1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x200f2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x200f3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x200f4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x200f5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x200f6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x200f7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1004a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1104a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1204a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1304a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x20025), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x2002d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12002d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x2002c), 	DDRNSDMC_PUB_MMR_BASE + (2*0xd0000), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90000), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90001), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90002), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90003), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90004), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90005), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90029), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9002a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9002b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9002c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9002d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9002e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9002f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90030), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90031), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90032), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90033), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90034), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90035), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90036), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90037), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90038), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90039), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9003a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9003b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9003c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9003d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9003e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9003f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90040), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90041), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90042), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90043), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90044), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90045), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90046), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90047), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90048), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90049), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9004a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9004b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9004c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9004d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9004e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9004f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90050), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90051), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90052), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90053), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90054), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90055), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90056), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90057), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90058), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90059), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9005a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9005b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9005c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9005d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9005e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9005f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90060), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90061), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90062), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90063), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90064), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90065), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90066), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90067), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90068), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90069), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9006a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9006b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9006c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9006d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9006e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9006f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90070), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90071), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90072), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90073), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90074), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90075), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90076), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90077), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90078), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90079), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9007a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9007b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9007c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9007d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9007e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9007f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90080), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90081), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90082), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90083), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90084), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90085), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90086), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90087), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90088), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90089), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9008a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9008b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9008c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9008d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9008e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9008f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90090), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90091), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90092), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90093), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90094), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90095), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90096), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90097), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90098), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90099), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9009a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9009b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9009c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9009d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9009e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9009f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900a0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900a1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900a2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900a3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900a4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900a5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900a6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900a7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900a8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900a9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40000), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40020), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40040), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40060), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40001), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40021), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40041), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40061), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40002), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40022), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40042), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40062), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40003), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40023), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40043), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40063), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40004), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40024), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40044), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40064), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40005), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40025), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40045), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40065), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40006), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40026), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40046), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40066), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40007), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40027), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40047), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40067), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40008), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40028), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40048), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40068), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40009), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40029), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40049), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40069), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000b), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004b), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002e), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006e), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4000f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4002f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4004f), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4006f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40010), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40030), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40050), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40070), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40011), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40031), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40051), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40071), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40012), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40032), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40052), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40072), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40013), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40033), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40053), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40073), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40014), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40034), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40054), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40074), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40015), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40035), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40055), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40075), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40016), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40036), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40056), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40076), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40017), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40037), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40057), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40077), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40018), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40038), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40058), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40078), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40019), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40039), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40059), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40079), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4001a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4003a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x4005a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x4007a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900aa), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900ab), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ac), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900ad), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ae), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900af), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900b0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900b1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900b2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900b3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900b5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900b6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900b7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900b8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900b9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ba), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900bb), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900bc), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900bd), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900be), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900bf), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900c2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900c3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900c4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900c5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900c6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900c7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900c8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900c9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ca), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900cb), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900cc), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900cd), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ce), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900cf), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900d0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900d1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900d2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900d3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900d4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900d5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900d6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900d7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900d8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900d9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900da), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900db), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900dc), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900dd), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900de), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900df), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900e0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900e1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900e2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900e3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900e4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900e5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900e6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900e7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900e8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900e9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ea), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900eb), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ec), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900ed), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900ee), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900ef), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900f0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900f1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900f2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900f3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900f4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900f5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900f6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900f7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900f8), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900f9), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900fa), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900fb), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900fc), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900fd), 	DDRNSDMC_PUB_MMR_BASE + (2*0x900fe), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x900ff), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90100), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90101), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90102), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90103), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90104), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90105), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90106), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90107), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90108), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90109), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9010a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9010b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9010c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9010d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9010e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9010f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90110), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90111), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90112), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90113), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90114), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90115), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90116), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90117), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90118), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90119), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9011a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9011b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9011c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9011d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9011e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9011f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90120), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90121), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90122), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90123), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90124), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90125), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90126), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90127), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90128), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90129), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9012a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9012b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9012c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9012d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9012e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9012f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90130), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90131), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90132), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90133), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90134), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90135), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90136), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90137), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90138), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90139), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9013a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9013b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9013c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9013d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9013e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9013f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90140), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90141), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90142), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90143), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90144), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90145), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90146), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90147), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90148), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90149), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9014a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9014b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9014c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9014d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9014e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9014f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90150), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90151), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90152), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90153), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90154), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90155), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90156), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90157), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90158), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90159), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9015a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9015b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9015c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9015d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9015e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9015f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90160), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90161), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90162), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90163), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90164), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90165), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90166), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90167), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90168), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90169), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9016a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9016b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9016c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9016d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9016e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9016f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90170), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90171), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90172), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90173), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90174), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90175), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90176), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90177), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90178), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90179), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9017a), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9017b), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9017c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9017d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9017e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9017f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90180), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90181), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90182), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90183), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90184), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90006), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90007), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90008), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90009), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9000a), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9000b), 
	DDRNSDMC_PUB_MMR_BASE + (2*0xd00e7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90017), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9001f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90026), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x400d0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x400d1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x400d2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x400d3), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x400d4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x400d5), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x400d6), 	DDRNSDMC_PUB_MMR_BASE + (2*0x400d7), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x200be), 	DDRNSDMC_PUB_MMR_BASE + (2*0x2000b), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x2000c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x2000d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x2000e), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12000b),
	DDRNSDMC_PUB_MMR_BASE + (2*0x12000c),	DDRNSDMC_PUB_MMR_BASE + (2*0x12000d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x12000e),	DDRNSDMC_PUB_MMR_BASE + (2*0x9000c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9000d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x9000e), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x9000f), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90010), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90011), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90012), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90013), 	DDRNSDMC_PUB_MMR_BASE + (2*0x20010), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x20011), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120010),
	DDRNSDMC_PUB_MMR_BASE + (2*0x120011),	DDRNSDMC_PUB_MMR_BASE + (2*0x40080), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40081), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40082), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40083), 	DDRNSDMC_PUB_MMR_BASE + (2*0x40084), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x40085), 	DDRNSDMC_PUB_MMR_BASE + (2*0x140080),
	DDRNSDMC_PUB_MMR_BASE + (2*0x140081),	DDRNSDMC_PUB_MMR_BASE + (2*0x140082),
	DDRNSDMC_PUB_MMR_BASE + (2*0x140083),	DDRNSDMC_PUB_MMR_BASE + (2*0x140084),
	DDRNSDMC_PUB_MMR_BASE + (2*0x140085),	DDRNSDMC_PUB_MMR_BASE + (2*0x400fd), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x400f1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10011), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10012), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10013), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10018), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10002), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100b2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x101b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x102b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x103b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x104b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x105b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x106b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x107b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x108b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11011), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11012), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11013), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11018), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11002), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110b2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x111b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x112b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x113b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x114b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x115b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x116b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x117b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x118b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12011), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12012), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12013), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12018), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12002), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120b2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x121b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x122b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x123b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x124b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x125b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x126b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x127b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x128b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13011), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13012), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13013), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13018), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13002), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130b2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x131b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x132b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x133b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x134b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x135b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x136b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x137b4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x138b4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x20089), 
	DDRNSDMC_PUB_MMR_BASE + (2*0xc0080), 	DDRNSDMC_PUB_MMR_BASE + (2*0x200cb), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10068), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10069), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10168), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10169), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10268), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10269), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10368), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10369), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10468), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10469), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10568), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10569), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10668), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10669), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10768), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10769), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10868), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10869), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100aa), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10062), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10001), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100a0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100a1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100a2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100a3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100a4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100a5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100a6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100a7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11068), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11069), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11168), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11169), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11268), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11269), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11368), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11369), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11468), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11469), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11568), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11569), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11668), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11669), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11768), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11769), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11868), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11869), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110aa), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11062), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11001), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110a0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110a1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110a2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110a3), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110a4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110a5), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110a6), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110a7), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12068), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12069), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12168), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12169), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12268), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12269), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12368), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12369), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12468), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12469), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12568), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12569), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12668), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12669), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12768), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12769), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12868), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12869), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120aa), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12062), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12001), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120a0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120a1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120a2), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120a3), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120a4), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120a5), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120a6), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120a7), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13068), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13069), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13168), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13169), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13268), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13269), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13368), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13369), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13468), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13469), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13568), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13569), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13668), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13669), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13768), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13769), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13868), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13869), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130aa), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13062), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13001), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130a0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130a1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130a2), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130a3), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130a4), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130a5), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130a6), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130a7), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x80),  	DDRNSDMC_PUB_MMR_BASE + (2*0x1080),  
	DDRNSDMC_PUB_MMR_BASE + (2*0x2080),  	DDRNSDMC_PUB_MMR_BASE + (2*0x10020), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10080), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10081), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100d0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100d1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1008c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1008d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x10180), 	DDRNSDMC_PUB_MMR_BASE + (2*0x10181), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x101d0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x101d1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1018c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1018d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x101c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x101c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x102c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x102c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x103c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x103c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x104c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x104c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x105c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x105c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x106c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x106c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x107c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x107c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x108c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x108c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x100ae), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100af), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11020), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11080), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11081), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110d0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110d1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1108c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1108d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x11180), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x11181), 	DDRNSDMC_PUB_MMR_BASE + (2*0x111d0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x111d1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1118c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1118d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x111c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x111c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x112c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x112c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x113c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x113c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x114c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x114c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x115c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x115c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x116c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x116c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x117c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x117c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x118c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x118c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x110ae), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x110af), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12020), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12080), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12081), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120d0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120d1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1208c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1208d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x12180), 	DDRNSDMC_PUB_MMR_BASE + (2*0x12181), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x121d0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x121d1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1218c), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1218d), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x121c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x121c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x122c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x122c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x123c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x123c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x124c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x124c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x125c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x125c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x126c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x126c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x127c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x127c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x128c0), 	DDRNSDMC_PUB_MMR_BASE + (2*0x128c1), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x120ae), 	DDRNSDMC_PUB_MMR_BASE + (2*0x120af), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13020), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13080), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13081), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130d0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130d1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1308c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1308d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x13180), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x13181), 	DDRNSDMC_PUB_MMR_BASE + (2*0x131d0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x131d1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x1318c), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x1318d), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x131c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x131c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x132c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x132c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x133c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x133c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x134c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x134c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x135c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x135c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x136c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x136c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x137c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x137c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x138c0), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x138c1), 	DDRNSDMC_PUB_MMR_BASE + (2*0x130ae), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x130af), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90201), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90202), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90203), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90205), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90206), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x90207), 	DDRNSDMC_PUB_MMR_BASE + (2*0x90208), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x20020), 	DDRNSDMC_PUB_MMR_BASE + (2*0x100080),
	DDRNSDMC_PUB_MMR_BASE + (2*0x101080),	DDRNSDMC_PUB_MMR_BASE + (2*0x102080),
	DDRNSDMC_PUB_MMR_BASE + (2*0x110020),	DDRNSDMC_PUB_MMR_BASE + (2*0x110080),
	DDRNSDMC_PUB_MMR_BASE + (2*0x110081),	DDRNSDMC_PUB_MMR_BASE + (2*0x1100d0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1100d1),	DDRNSDMC_PUB_MMR_BASE + (2*0x11008c),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11008d),	DDRNSDMC_PUB_MMR_BASE + (2*0x110180),
	DDRNSDMC_PUB_MMR_BASE + (2*0x110181),	DDRNSDMC_PUB_MMR_BASE + (2*0x1101d0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1101d1),	DDRNSDMC_PUB_MMR_BASE + (2*0x11018c),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11018d),	DDRNSDMC_PUB_MMR_BASE + (2*0x1100c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1100c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1101c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1101c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1102c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1102c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1103c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1103c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1104c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1104c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1105c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1105c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1106c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1106c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1107c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1107c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1108c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1108c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1100ae),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1100af),	DDRNSDMC_PUB_MMR_BASE + (2*0x111020),
	DDRNSDMC_PUB_MMR_BASE + (2*0x111080),	DDRNSDMC_PUB_MMR_BASE + (2*0x111081),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1110d0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1110d1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11108c),	DDRNSDMC_PUB_MMR_BASE + (2*0x11108d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x111180),	DDRNSDMC_PUB_MMR_BASE + (2*0x111181),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1111d0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1111d1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11118c),	DDRNSDMC_PUB_MMR_BASE + (2*0x11118d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1110c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1110c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1111c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1111c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1112c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1112c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1113c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1113c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1114c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1114c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1115c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1115c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1116c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1116c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1117c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1117c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1118c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1118c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1110ae),	DDRNSDMC_PUB_MMR_BASE + (2*0x1110af),
	DDRNSDMC_PUB_MMR_BASE + (2*0x112020),	DDRNSDMC_PUB_MMR_BASE + (2*0x112080),
	DDRNSDMC_PUB_MMR_BASE + (2*0x112081),	DDRNSDMC_PUB_MMR_BASE + (2*0x1120d0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1120d1),	DDRNSDMC_PUB_MMR_BASE + (2*0x11208c),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11208d),	DDRNSDMC_PUB_MMR_BASE + (2*0x112180),
	DDRNSDMC_PUB_MMR_BASE + (2*0x112181),	DDRNSDMC_PUB_MMR_BASE + (2*0x1121d0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1121d1),	DDRNSDMC_PUB_MMR_BASE + (2*0x11218c),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11218d),	DDRNSDMC_PUB_MMR_BASE + (2*0x1120c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1120c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1121c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1121c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1122c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1122c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1123c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1123c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1124c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1124c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1125c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1125c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1126c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1126c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1127c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1127c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1128c0),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1128c1),	DDRNSDMC_PUB_MMR_BASE + (2*0x1120ae),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1120af),	DDRNSDMC_PUB_MMR_BASE + (2*0x113020),
	DDRNSDMC_PUB_MMR_BASE + (2*0x113080),	DDRNSDMC_PUB_MMR_BASE + (2*0x113081),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1130d0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1130d1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11308c),	DDRNSDMC_PUB_MMR_BASE + (2*0x11308d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x113180),	DDRNSDMC_PUB_MMR_BASE + (2*0x113181),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1131d0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1131d1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x11318c),	DDRNSDMC_PUB_MMR_BASE + (2*0x11318d),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1130c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1130c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1131c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1131c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1132c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1132c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1133c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1133c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1134c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1134c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1135c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1135c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1136c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1136c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1137c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1137c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1138c0),	DDRNSDMC_PUB_MMR_BASE + (2*0x1138c1),
	DDRNSDMC_PUB_MMR_BASE + (2*0x1130ae),	DDRNSDMC_PUB_MMR_BASE + (2*0x1130af),
	DDRNSDMC_PUB_MMR_BASE + (2*0x190201),	DDRNSDMC_PUB_MMR_BASE + (2*0x190202),
	DDRNSDMC_PUB_MMR_BASE + (2*0x190203),	DDRNSDMC_PUB_MMR_BASE + (2*0x190205),
	DDRNSDMC_PUB_MMR_BASE + (2*0x190206),	DDRNSDMC_PUB_MMR_BASE + (2*0x190207),
	DDRNSDMC_PUB_MMR_BASE + (2*0x190208),	DDRNSDMC_PUB_MMR_BASE + (2*0x120020),
	DDRNSDMC_PUB_MMR_BASE + (2*0x20077), 	DDRNSDMC_PUB_MMR_BASE + (2*0x20072), 
	DDRNSDMC_PUB_MMR_BASE + (2*0x20073), 	DDRNSDMC_PUB_MMR_BASE + (2*0x400c0), 
};
#endif
static void retention_exit(void) {
  // phy pub book  page 186

  // debug_io_retention_exit = 1;
  mww(DDRNSDMC_PUB_MMR_BASE + 2*0xd0000,0x0);
  mww(DDRNSDMC_PUB_MMR_BASE + 2*0xc0080,0x3);
  mww(DDRNSDMC_PUB_MMR_BASE + 2*0x20089,0x1);   // ???

  #ifdef EN_TRAIN
    pub_restore();
  #else
    skiptrain_restore();
  #endif

  mww(DDRNSDMC_PUB_MMR_BASE + 2*0xc0080,0x0);
  mww(DDRNSDMC_PUB_MMR_BASE + 2*0xd0000,0x1);

  // debug_io_retention_exit = 2;
}

void remove_power(void) {
  int i = 0;
  unsigned int data;
  unsigned int *debug_remove_power = (unsigned int *)(unsigned long)0xce200004;

// WAGNER_SIM_FUNC.Chip.Core.PMU_Core.pmu_o_clampz = clampz;
  // page 284

  *debug_remove_power = 1;
  //step1   PCTRL_n.port_en = 0
  for(i = 0; i <16; i++)
    mwl(DDR3_TOP_CTRL_BASE+PCTRL_0 + 0xb0 * i, 0);


  *debug_remove_power = 2;
  //step2
  mrl(DDR3_TOP_CTRL_BASE +  PSTAT,  data); 
  while (data  != 0x0) {
    mrl(DDR3_TOP_CTRL_BASE +  PSTAT,  data); 
  }

  //step3/4   no SBRCTL function


  *debug_remove_power = 5;
  //step5   Program  bit[8]   DFILPCF0.dfi_lp_en_sr = 0 ; Poll bit[1] DFISTAT.dfi_lp_ack = 0
  mrl(DDR3_TOP_CTRL_BASE  + DFILPCFG0,  data);
  (*(unsigned long *)VPL_RET_RAM_BASE) = data;

  mwl(DDR3_TOP_CTRL_BASE+ DFILPCFG0,  data & 0xfffffeff);
  
  mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  while ((data & 2)  != 0) {
    mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  }

  *debug_remove_power = 6;
  //step6  wait [2:0] STAT.operating_mode!=11
  mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  while ((data & 0x7)  == 0x3) {
    mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  }


  *debug_remove_power = 7;
  //step7 Write ��1�� to bit[5] PWRCTL.selfref_mwl   ; bit [6] PWRCTL.stay_in_selfref = 0 
  mrl(DDR3_TOP_CTRL_BASE + PWRCTL,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ PWRCTL,  (data | 0x20) & 0xffffffbf);


  *debug_remove_power = 8;
  //step8  wait  bit[5:4] selfref_type == 2 ; bit[9:8]  selfref_state == 2 ; 
  //       Self Refresh Power Downstate is entered.

  mrl(DDR3_TOP_CTRL_BASE + STAT,  data); 
  while ((((data >> 4) & 3) != 0x2) ||  (((data >> 8) & 3)  != 0x2) ) {
    mrl(DDR3_TOP_CTRL_BASE + STAT,  data);  
  }



  *debug_remove_power = 9;

  mwl(DDR3_TOP_CTRL_BASE+ SWCTL, 0x0);//Set mwl_done = 0 

  //step9   [12:8]dfi_frequency 
  mrl(DDR3_TOP_CTRL_BASE + DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data | 0x00001f00);

  *debug_remove_power = 10;
  //step10   [5] dfi_init_start  =1
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data | 0x00001f00 | 0x20); 

  *debug_remove_power = 11;
  //step11   [0] polls DFISTAT.dfi_init_complete=0
  mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  while ((data & 1) == 1) {
    mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  }

  *debug_remove_power = 12;
  //step12   [5] dfi_init_start = 0
  mrl(DDR3_TOP_CTRL_BASE + DFIMISC,  data); 
  mwl(DDR3_TOP_CTRL_BASE+ DFIMISC,  data & 0xfffffdf); 


  *debug_remove_power = 13;
  //step13   [0] polls DFISTAT.dfi_init_complete=1
  mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data); 
  while ((data & 1) == 0) {
    mrl(DDR3_TOP_CTRL_BASE + DFISTAT,  data);  
  }

  *debug_remove_power = 14;
  //step14    Place IOs in retention mode  

  // full process to enter LP3/IO Retention :
  //  PwrOkIn (0) ->  DFICLK (off) -> VDD/VAA (off)
  retention_entry();
  *debug_remove_power = 15;

  for ( i = 0; i < 100; i++) asm volatile("nop\n\t");
//  test.PwrOkIn = 0;
//  force SIM_CHIP_TEST.Chip.Core.DDRNSDMC_Core.Core.u_DWC_DDRPHY0_top.PwrOkIn = 0;
//    mwl(DDRNSDMC_MISC_MMR_BASE  +  (( (17 << 4) + DDRC_PWROKIN) *4 )  , 0,2); 

//  force WAGNER_SIM_FUNC.Chip.Core.DDRNSDMC_Core.ddrnsdmc_i_ext_pwr_ok = 0;
  
  mwl((SYSC_SECURE_MMR_BASE+0x00000164), 0x00800000);	//  PUB pwr_ok [23] = 0

  for ( i = 0; i < 100; i++) asm volatile("nop\n\t");

  //WAGNER_SIM_FUNC.Chip.Core.PMU_Core.pmu_o_clampz(0);

//display("Clear alarm status bit...");
//mwl(PMU_MMR_BASE+0x00000008, 0x00000111);
//
//display("Wait for alarm status bit cleared....");
//mrl(PMU_MMR_BASE+0x00000004, data);
//while ((data&0x00000100)!==0x00000000)
//{
//    for ( i = 0; i < 100; i++) asm volatile("nop\n\t");
//    mrl(PMU_MMR_BASE+0x00000004, data);
//}
//
//display("Enable RTC divided clock output...");
//mwl(PMU_MMR_BASE+0x00000008, 0x00001011);
//
//display("Set CPZ to 1'b0...");
//Read_Shift_Register("Read CONFIG register", 2, 4'b1110, data);
//#2us;
//Write_Shift_Register("Write CONFIG register", 2, 4'b1110, data&0xFFFBFFFF);
//#2us;   //  PUB pwr_ok [23] = 0
//
//display("Set EAON and ECA to 1'b1...");
//Read_Shift_Register("Read CONFIG register", 2, 4'b1110, data);
//#2us;
//Write_Shift_Register("Write CONFIG register", 2, 4'b1110, data|0x000A0000);
  //step15  remove power

  //suspend_power_down();

  //force WAGNER_SIM_FUNC.Chip.Core.DDRNSDMC_Core.Core.u_DWC_DDRPHY0_top.VAA = 0;
  //force WAGNER_SIM_FUNC.Chip.Core.DDRNSDMC_Core.Core.u_DWC_DDRPHY0_top.VDD = 0;
  // remove other power mctl2 ?

}

static void retention_entry(void) {
  //int i = 0;

  // page 284
// phy pub book  page 184
  // debug_io_retention_entry = 1;

  mww(DDRNSDMC_PUB_MMR_BASE + 2 * 0xd0000,  0x0);
  mww(DDRNSDMC_PUB_MMR_BASE + 2 * 0xc0080,  0x3);
  
  #ifdef EN_TRAIN
    pub_save();
  #else
    skiptrain_save();
  #endif

  mww(DDRNSDMC_PUB_MMR_BASE + 2 * 0xc0080,  0x0);
  mww(DDRNSDMC_PUB_MMR_BASE + 2 * 0xd0000,  0x1);

  // debug_io_retention_entry = 2;
}
void mctl_initial_post(void)
{
  unsigned int data;
  unsigned int *debug = (unsigned int *)(unsigned long)0xce200004;
  unsigned char mrn = 4;
  unsigned int val;

 *debug =15;
//------------------------
//Step 15  Set SWCTL.mwl_done to 0
//------------------------
// w uMCTL2 (0x320     SWCTL) Register
    mwl(DDR3_TOP_CTRL_BASE+0x00000320, 0x00000000); //Set mwl_done = 0

 *debug =16;
//------------------------
//Step 16  Set DFIMISC.dfi_init_start to 1
//------------------------
// w uMCTL2 (0x1b0     DFIMISC) Register
    mrl(DDR3_TOP_CTRL_BASE+0x000001b0,data);
    //elaine//display(" uMCTL2 0x1b0 DFIMISC Register Value = %0x8x", rdata_out);
    //elaine//    mwl(DDR3_TOP_CTRL_BASE+0x000001b0, ( rdata_out | 0x00000020)); //bit[5] =1 Set dfi_init_start = 1


#ifdef  TRAIN_2ND_FREQ //DDR_ENABLE_FSP
    mwl(DDR3_TOP_CTRL_BASE+0x000001b0, (data | 0x00000120)); //bit[5]/bit[8] =1 Set
//
#else
    mwl(DDR3_TOP_CTRL_BASE+0x000001b0, (data | 0x00000020)); //bit[5] =1 Set  dfi_init_start = 1
#endif



 *debug =17;
//------------------------
//Step 17  Set SWCTL.mwl_done to 1
//------------------------
// w uMCTL2 (0x320     SWCTL) Register
    mwl(DDR3_TOP_CTRL_BASE+0x00000320, 0x00000001); //Set mwl_done = 1

//Polling SWSTAT.mwl_done_ack =1
// r uMCTL2 (0x324c     SWSTAT) Register
  //rdata_out = 0x0;
  //mrl(DDR3_TOP_CTRL_BASE+0x00000324, rdata_out); //read
  //while ( ((rdata_out & 0x00000001) == 0x0) ) {
  //      mrl(DDR3_TOP_CTRL_BASE+0x00000324, rdata_out); //read
  //}
//    while (!(READ(DDR3_TOP_CTRL_BASE+0x00000324) & 0x00000001)) {}

//    test.ddrc_apb_poll_rdata (DDR3_TOP_CTRL_BASE+0x00000324, 320x1, 320x1);
  mrl(DDR3_TOP_CTRL_BASE+0x00000324, data); //read
  while ( ((data & 0x00000001) == 0x0) ) {
        mrl(DDR3_TOP_CTRL_BASE+0x00000324, data); //read
  }


 *debug =18;
//------------------------
//Step 18  Polling DFISTAT.dfi_init_complete = 1
//------------------------
//Polling DFISTAT.dfi_init_complete = 1
// r uMCTL2 (0x1bc     DFISTAT) Register
  //rdata_out = 0x0;
  //  mrl(DDR3_TOP_CTRL_BASE+0x000001bc, rdata_out);
  //while ( ((rdata_out & 0x00000001) == 0x0) ) {
  //      mrl(DDR3_TOP_CTRL_BASE+0x000001bc, rdata_out); // check bit[0] dfi_init_complete = 1
  //}
//    while (!(READ(DDR3_TOP_CTRL_BASE+0x000001bc) & 0x00000001)) {}
//    test.ddrc_apb_poll_rdata (DDR3_TOP_CTRL_BASE+0x000001bc, 320x1, 320x1);
  mrl(DDR3_TOP_CTRL_BASE+0x000001bc, data);
  while ( ((data & 0x00000001) == 0x0) ) {
        mrl(DDR3_TOP_CTRL_BASE+0x000001bc, data); // check bit[0] dfi_init_complete = 1
  }


 *debug =19;
//------------------------
//Step 19  Set SWCTL.mwl_done to 0
//------------------------
// w uMCTL2 (0x320     SWCTL) Register
    mwl(DDR3_TOP_CTRL_BASE+0x00000320, 0x00000000); //Set mwl_done = 0


 *debug =20;
//------------------------
//Step 20  Set DFIMISC.dfi_init_start to 0
//------------------------

//wait (AXI_TB.AXI_Core.U_DDR_TOP.dfi_init_complete);

// w uMCTL2 (0x1b0     DFIMISC) Register
    mrl(DDR3_TOP_CTRL_BASE+0x000001b0,data);
    //elaine//display(" uMCTL2 0x1b0 DFIMISC Register Value = %0x8x", rdata_out);
    mwl(DDR3_TOP_CTRL_BASE+0x000001b0, (data & 0xffffffdf)); //bit[5] =0 Set dfi_init_start = 0

 *debug =21;

#ifdef  EN_TRAIN //DDR_ENABLE_FSP
#ifdef TRAIN_2ND_FREQ
    mrl(DDR3_TOP_CTRL_BASE + MSTR,data);
    mwl(DDR3_TOP_CTRL_BASE+ MSTR, data | 0x20000000);//set 1 in MSTR[29] frequency_mode
//
    mrl(DDR3_TOP_CTRL_BASE + PWRCTL,data);
    mwl(DDR3_TOP_CTRL_BASE+ PWRCTL, data| 0x00000040);
#else
//    //Set PWRCTL.stay_in_selfref = 1 to stay "Self refresh 2" after exiting "Self refresh power down".
    mrl(DDR3_TOP_CTRL_BASE + PWRCTL,data);
    mwl(DDR3_TOP_CTRL_BASE+ PWRCTL, data| 0x00000020);
//
#endif
#endif



 *debug =22;
//------------------------
//Step 22  Set DFIMISC.dfi_init_complete_en = 1
//------------------------
// w uMCTL2 (0x1b0     DFIMISC) Register
    mrl(DDR3_TOP_CTRL_BASE+0x000001b0,data);
    //elaine//display(" uMCTL2 0x1b0 DFIMISC Register Value = %0x8x", rdata_out);
    mwl(DDR3_TOP_CTRL_BASE+0x000001b0, (data | 0x00000001)); //bit[0] =1 Set dfi_init_complete_en =1


 *debug =23;
//------------------------
//Step 23  Set PWRCTL.selfref_mwl to 0
//------------------------
// w uMCTL2 (0x030     PWRCTL) Register


    mrl(DDR3_TOP_CTRL_BASE+0x00000030,data);
    //elaine/display(" uMCTL2 0x030 PWRCTL Register Value = %0x8x", rdata_out);
    mwl(DDR3_TOP_CTRL_BASE+0x00000030, (data & 0xffffffdf)); //bit[5] =0 Set selfref_mwl =0, Software exit from self-refresh
	
#ifdef TRAIN_2ND_FREQ
#else
   while (1) {
     mrl(DDR3_TOP_CTRL_BASE+0x00000004,data);
     if ( (data & 0x300) == 0x0)
       break;
   }
#endif

    mrn = 8;
    mwl(DDR3_TOP_CTRL_BASE + 0x00000014, mrn << 8);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000010, 0x80000011);
    do {
      mrl(DDR3_TOP_CTRL_BASE + 0x00000010, val);
    }while (val & 0x80000000);
    mrl(APM_BASE + 0x00000474, val);
    val &= 0xFF;
    INFO("MR%d: 0x%x\n", mrn, val);

  if (val == 0x0) {//2Gb x 2 = 4Gb
    mwl(DDR3_TOP_CTRL_BASE + RFSHTMG, 0x00000068 | (nREFI << 16));  //tRFC 130ns
    mwl(DDR3_TOP_CTRL_BASE + DRAMTMG14, 0x0000006E);  //tXSR
  } else if (val == 0x8) {//4Gb x 2 = 8Gb
    mwl(DDR3_TOP_CTRL_BASE + RFSHTMG, 0x00000089 | (nREFI << 16));  //tRFC 180ns
    mwl(DDR3_TOP_CTRL_BASE + DRAMTMG14, 0x0000008F);  //tXSR
  } else if (val == 0x10) {//8Gb x 2 = 16Gb
    mwl(DDR3_TOP_CTRL_BASE + RFSHTMG, 0x000000D5 | (nREFI << 16));  //tRFC 280ns
    mwl(DDR3_TOP_CTRL_BASE + DRAMTMG14, 0x000000DB);  //tXSR
  } else {
    mwl(DDR3_TOP_CTRL_BASE + RFSHTMG, 0x000000D5 | (nREFI << 16));  //tRFC
    mwl(DDR3_TOP_CTRL_BASE + DRAMTMG14, 0x000000DB);  //tXSR
  }

#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x0f0f0606);	// 256 MB 2Gb
#else
  if ( val == 0x0)
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x0f0f0707);	// 512 MB 4Gb
  else if ( val== 0x8)
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x0f070707);	// 1024 MB 8Gb
  else if ( val == 0x10)
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x07070707);	// 2048 MB 16Gb
  else
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x07070707);	// 2048 MB 16Gb
#endif
    mrl(DDR3_TOP_CTRL_BASE + 0x00000218, val);
    INFO("addrmap 6: 0x%x\n", val);

#ifdef EN_TRAIN //DDR_ENABLE_FSP
#ifdef TRAIN_2ND_FREQ

   while (1) {
     mrl(DDR3_TOP_CTRL_BASE+0x00000004,data);
    if ( (data & 0x300) == 0x300)
       break;
   }

    mrl(DDR3_TOP_CTRL_BASE+ PWRCTL,data);
    data = data & (~(1 << 6)) ;
    mwl(DDR3_TOP_CTRL_BASE+PWRCTL, data);

    do {
      mrl(DDR3_TOP_CTRL_BASE+ STAT,data);
    } while((data & 0x00000300) != 0 );

#endif
#endif

 *debug =24;
//------------------------
//Step 24  Set SWCTL.mwl_done to 1
//------------------------
// w uMCTL2 (0x320     SWCTL) Register
    mwl(DDR3_TOP_CTRL_BASE+0x00000320, 0x00000001); //Set mwl_done = 1

//Polling SWSTAT.mwl_done_ack =1
// r uMCTL2 (0x324     SWSTAT) Register
  //rdata_out = 0x0;
  //  mrl(DDR3_TOP_CTRL_BASE+0x00000324, &rdata_out); //read
  //while ( ((rdata_out & 0x00000001) == 0x0) ) {
  //      mrl(DDR3_TOP_CTRL_BASE+0x00000324, rdata_out); //read
  //}
//    while (!(mrl(DDR3_TOP_CTRL_BASE+0x00000324) & 0x00000001),data);
  //  test.ddrc_apb_poll_rdata (DDR3_TOP_CTRL_BASE+0x00000324, 320x1, 320x1);
  mrl(DDR3_TOP_CTRL_BASE+0x00000324, data); //read
  while ( ((data & 0x00000001) == 0x0) ) {
        mrl(DDR3_TOP_CTRL_BASE+0x00000324, data); //read
  }

 *debug =25;
//------------------------
//Step 25 Wait umctl2 status normal
//------------------------
  //LPDDR3
  //000 = Init
  //001 = Normal
  //010 = Power down
  //011 = Self-refresh
  //1XX = Deep power down/ Maximum Power Saving Mode

  //LPDDR4
  //000 = Init
  //001 = Normal
  //010 = Power Down
  //011 = Self-Refresh/Self-Refresh power down

//Polling STAT
// r uMCTL2 (0x004     STAT) Register
  //rdata_out = 0x0;
  //mrl(DDR3_TOP_CTRL_BASE+0x00000004, rdata_out);
  //$display(" uMCTL2 0x004 STAT Register Value = %0x8x", rdata_out);
  //while ( ((rdata_out & 0x00000003) == 0x0) ) {
  //      mrl(DDR3_TOP_CTRL_BASE+0x00000004, rdata_out);
  //  $display(" uMCTL2 0x004 STAT Register Value = %0x8x", rdata_out);
  //}
//    while ((mrl(DDR3_TOP_CTRL_BASE+0x00000004) & 0x00000003) == 0,data);

   while (1) {
     mrl(DDR3_TOP_CTRL_BASE+0x00000004,data);
     if ( (data & 0x3) == 1)
       break;
   }
   *debug =26;

 #ifdef EN_TRAIN
//   // ZQCTL0
//
//    #150ns;  // fix tRFCab
//    #ifdef  EN_TRAIN //DDR_ENABLE_FSP
        mwl(DDR3_TOP_CTRL_BASE+0x00000180, 0xc3200018);
//   #else
//      mwl(DDR3_TOP_CTRL_BASE+0x00000180, 0x03200018,2);
//    #endif
//
//   //MRCTRL1
//    mwl(DDR3_TOP_CTRL_BASE+0x00000014, 0x00000d80,2);
    mwl(DDR3_TOP_CTRL_BASE+0x00000014, 0x00000d88);
   //MRCTRL0
    mwl(DDR3_TOP_CTRL_BASE+0x00000010, 0x00000010);
    mwl(DDR3_TOP_CTRL_BASE+0x00000010, 0x80000010);
    while (1) {
      mrl(DDR3_TOP_CTRL_BASE+0x00000018,data);
      if ( (data & 0x1) == 0)
        break;
    }
//
#endif
   *debug =27;

	writel(0x11, 0xce200004);
	INFO("dram_test in post\n");

	writel(0x55aa55aa, 0x10);
	writel(0x55aa0000, 0x14);

	if (readl(0x10) != 0x55aa55aa) {
		writel(0xee, 0xce200004);
		ERROR("run time write/read test: Error\n");
		return;
	}
	if (readl(0x14) != 0x55aa0000) {
		writel(0xee, 0xce200004);
		ERROR("run time write/read test: Error\n");
		return;
	}
	INFO("run time write/read test. PASS\n");

	writel(0xCC, 0xce200004);

}

#define TEST_ADDR (0x10)
void dram_test(void)
{
	int i = 0, j = 0, k = 1;
#if 0
  INFO("DMAC prepare data.\n");
  for (i = 0; i < (0x8800 << 13); i += 0x8800) {
	  dmac_copy(TEST_ADDR + i, 0xC0020000, 0x8800);
  }

  INFO("continuously read check....");
  while(k) {
    for (j = 0; j < (0x8800 << 13); j += 0x8800) {
      for (i = 0; i < 0x8800; i += 4) {
        if (readl(TEST_ADDR + i + j) != readl(0xC0020000 + i)) {
          ERROR("fw unmatch at 0x%08x, read 0x%x, shall be 0x%x\n", TEST_ADDR + i, readl(TEST_ADDR + i + j), readl(0xC0020000 + i));
          return;
        }
      }
    }
    INFO("%d pass.!!\n", k++);
  }

#else
  INFO("continuously write check....");
  while(k) {
    INFO("writing data area 1....");
    for (i = 0; i < (0x8800 << 13); i += 0x8800) {
      dmac_copy(TEST_ADDR + i, 0xC0020000, 0x8800);
    }

    INFO("checking data area 1....");
    for (j = 0; j < (0x8800 << 13); j += 0x8800) {
      for (i = 0; i < 0x8800; i += 4) {
        if (readl(TEST_ADDR + i + j) != readl(0xC0020000 + i)) {
          ERROR("fw unmatch at 0x%08x, read 0x%x, shall be 0x%x\n", TEST_ADDR + i, readl(TEST_ADDR + i + j), readl(0xC0020000 + i));
          return;
        }
      }
    }

    INFO("writing data area 2....");
    for (i = 0; i < (0x8800 << 13); i += 0x8800) {
      dmac_copy(TEST_ADDR + i, 0xFFFF0000, 0x8800);
    }

    INFO("checking data area 2....");
    for (j = 0; j < (0x8800 << 13); j += 0x8800) {
      for (i = 0; i < 0x8800; i += 4) {
        if (readl(TEST_ADDR + i + j) != readl(0xFFFF0000 + i)) {
          ERROR("rom unmatch at 0x%08x, read 0x%x, shall be 0x%x\n", TEST_ADDR + i, readl(TEST_ADDR + i + j), readl(0xFFFF0000 + i));
          return;
        }
      }
    }
    INFO("%d pass.!!\n", k++);
  }
#endif
}

void initial_pre_lp3(void) {
    unsigned int data;

    //MSTR
    //[31:30]	device_config = 0x2 (x16)
    //[29]	frequency_mode = 0x0
    //[28:24]	active_ranks = 0x1
    //[22]	frequency_ratio	= 0x0
    //[21:20]	active_logical_ranks = 0x0
    //[19:16]	burst_rdwr = 0x8	//BL16
    //[15]	dll_off_mode = 0x0
    //[13:12]	data_bus_width = 0x0
    //[11]	geardown_mode = 0x0
    //[10]	en_2t_timing_mode = 0x0
    //[9]	burstchop = 0x0
    //[8]	burst_mode = 0x0
    //[5]	lpddr4 = 0x1
    //[4]	ddr4 = 0x0
    //[3]	lpddr3 = 0x0
    //[2]	lpddr2 = 0x0
    //[1]	mobile = 0x0
    //[0]	ddr3 = 0x0

   #ifdef LPDDR4_DATA_BUS_16
      mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81081020);  // A: 1.2G
   #else
      mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81080020);
   #endif

//#ifdef EN_TRAIN
//    #ifdef DDRNSDMC_TEST_LP3_RETENTION
//        #ifdef LPDDR4_DATA_BUS_16
//           mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81081020);
//        #else
//           mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81080020);
//        #endif
//    #else
//        #ifdef LPDDR4_DATA_BUS_16
//           mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81081020);
//        #else
//           mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81080020);
//        #endif
//    #endif
//#else
//   #ifdef LPDDR4_DATA_BUS_16
//      mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81081020);
//   #else
//      mwl(DDR3_TOP_CTRL_BASE+0x00000000, 0x81080020);
//   #endif
//#endif

    //STAT RO
    //[12]	selfref_cam_not_empty 
    //[9:8]	selfref_state
    //[5:4]	selfref_type
    //[x:0]	operation_mode

    //MSTR1 LPDDR(NA)

    //MRCTRL0
    //[31]	mr_wr = 0x0
    //[30]	pba_mode = 0x0 (DDR4 only)
    //[x:16]	mr_cid = 0x0 (CID EN)
    //[15:12]	mr_addr = 0x0 (LPDDR4 NA)
    //[x:4]	mr_rank = 0x1
    //[3]	mwl_init_int = 0x0
    //[2]	pad_en = 0x0 (DDR4 only)
    //[1]	mpr_en = 0x0 (DDR4 only)
    //[0]	mr_type = 0x0 
    mwl(DDR3_TOP_CTRL_BASE+0x00000010, 0x00000010); //Mode Register Access for Rank0 

    //MRCTRL1
    //[x:0]	mr_data (LPDDR4 NA)

    //MRSTAT RO
    //[8]	pda_done
    //[0]	mr_wr_busy
    
    //MRCTRL2 
    //[31:0]	mr_device_sel (DDR4 only)

    //DERATEEN
    //[13]	derate_mr4_pause_fc = 0x0
    //[12]	derate_mr4_tuf_dis = 0x0
    //[10:8]	rc_derate_value = 0x0
    //[7:4]	derate_byte = 0x0
    //[2:1]	derate_value = 0x0
    //[0]	derate_enable = 0x1; 
    mwl(DDR3_TOP_CTRL_BASE+0x00000020, 0x00001203); //Derate Enable 

    //DERATEINT
    //[31:0]	mr4_read_interval = 0xd0000000
    mwl(DDR3_TOP_CTRL_BASE+0x00000024, 0x08000000); //Interval between two MR4 read

    //MSTR2
    //[1:0]	target_frequency

    //DERATECTL (LPDDR2 only)
    //[2]	derate_temp_limit_intr_force 
    //[1]	derate_temp_limit_intr_cle
    //[0]	derate_temp_limit_intr_en
    //

    //PWRCTL
    //[8]	lpddr4_sr_allowed
    //[7]	dis_cam_drain_selfref
    //[6]	stay_in_selfref
    //[5]	selfref_mwl
    //[4]	mpsm_en
    //[3]	en_dif_dram_clk_disable
    //[2]	deeppowerdoen_en
    //[1]	powerdown_en
    //[0]	selfref_en

   // *debug =2222;

#ifdef TRAIN_2ND_FREQ
#ifdef EN_TRAIN
    mwl(DDR3_TOP_CTRL_BASE+0x00000030, 0x00000020); //kenny
#endif
#endif

    //PWRTMG
    //[23:16]	selfref_to_x32
    //[15:8]	t_dpd_x4096
    //[4:0]	powerdown_to_x32

    mwl(DDR3_TOP_CTRL_BASE+0x00000034, 0x00200010);  //Wythe

    //HWLPCTL
    //[27:16]	hw_lp_idle_x32
    //[1]	hw_lp_exit_idle_en
    //[0]	hw_lp_en

    //HWFFCCTL  (not support)
    //HWFFCSTAT (not support)
    //HWFFCEX_RANK1 (not_support)
    //HWFFCEX_RANK2 (not_support)
    //HWFFCEX_RANK3 (not_support)

    //SCHED1
    //Offset: 0x254
    //[31]   opt_hit_gt_hpr
    //[30:28]      page_hit_liit_rd
    //[26:24]      page_hit_liit_wr
    //[22:20]      visible_windows_liit_rd
    //[18:16]      visible_windows_liit_wr
    //[15:12]   delay_switch_write
    //[7:0]  pageclose_tier
    //srdata(`DDRNSDMC_MCTL_MMR_BASE+'h00000254,data);
    //sw(`DDRNSDMC_MCTL_MMR_BASE+'h00000254, ( data | 'h000000FF),2);
    data = readl(DDR3_TOP_CTRL_BASE+0x00000254);
    writel(data | 0x0000007F, DDR3_TOP_CTRL_BASE+0x00000254);

    //PERLPR1
    data = readl(DDR3_TOP_CTRL_BASE + 0x00000264);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000264, 0x1F00007F);  //

    //PERFWR1
    data = readl(DDR3_TOP_CTRL_BASE + 0x0000026C);
    mwl(DDR3_TOP_CTRL_BASE + 0x0000026C,  0x2F0003FF);  // 

    //SCHED3
    data = readl(DDR3_TOP_CTRL_BASE + 0x00000270);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000270,  0x0404020C);  // 

    //RESHCTL0
    //[31:27] 	refresh_to_ab_x32 = 0x10
    //[23:20]	refresh_margin = 0x2
    //[16:12]	refresh_to_x1_x32 = 0x10
    //[9:4]	refresh_burst = 0x3
    //[2]	pre_bank_refresh = 0x0
    //[1:0]	auto_refab_en = 0x0
    mwl(DDR3_TOP_CTRL_BASE+0x00000050, 0x80210000); //RFSHCTL0, Refresh Control, 4 post burst refresh, use x32

    //RESHCTL1 (RANK >1)
    //[27:16]	refresh_timer1_start_value_x32
    //[11:0]	refresh_timer0_start_value_x32
    //RESHCTL2 (RANK >1)
    //[27:16]	refresh_timer3_start_value_x32
    //[11:0]	refresh_timer4_start_value_x32
    //RESHCTL4 (CID EN)
    //[10:0]	refresh_timer_lr_offset_x32
    //RESHCTL3
    //[x:16]	rank_dis_refresh = 0x0
    //[6:4]	refresh_mode = 0x0
    //[1]	refresh_update_level = 0x0
    //[0]	dis_auto_refresh = 0x0

    //RESHTMG
    //[31]	t_rfc_nom_x1_sel = 0x0 (x32)
    //[27:16]	t_rfc_nom_x1_x32 = tREFI = 6246(ab), 780(pb)
    //                                     rounddown(6246 /2 /32) = 0x61
    //[15]	lpddr3_trefbw_en = 0x0 (lpddr3 only)
    //[9:0]	t_rfc_min = tRFC = 208(ab), 96(pb)
    //					   roundup(208 /2) = 0x68
    // mwl(DDR3_TOP_CTRL_BASE+0x00000064, 0x00610068);
    mwl(DDR3_TOP_CTRL_BASE+0x00000064, 0x006000D5);
    mwl(DDR3_TOP_CTRL_BASE+0x00000064, 0x000000D5 | (nREFI << 16));

    //RFSHTMG1
    //[23:16]	t_pbr2pbr = 96 /2 = 0x30
    //[7:0]	t_rfc_min_dir (CID EN) = 0x8C
    mwl(DDR3_TOP_CTRL_BASE+0x00000068, 0x0030008c);

    //----------------------------------------------------
    //ECCCFG0 ~ CRCPARSTAT (not support)

    //INIT0
    //[31:30]	skip_dram_init = 0x0 (initRun)
    //[25:16]	post_cke_x1024 = 2us = 2000/0.625/1024/2 = 1.5625 = 0x2
    //[11:0]	pre_clk_x1024 = tINIT3 = 2ms = 2000000/0.625/1024/2 = 0x61B



#ifdef EN_TRAIN
//    mwl(DDR3_TOP_CTRL_BASE+0x000000d0, 0xc0020010);   // kenny
    mwl(DDR3_TOP_CTRL_BASE+0x000000d0, 0xC002061b);   // kenny
#else
    //mwl(DDR3_TOP_CTRL_BASE+0x000000d0, 0x00020010);
    mwl(DDR3_TOP_CTRL_BASE+0x000000d0, 0x00020010);   // kenny
#endif


    //INIT1, For DDR3/DDR4 or LPDDR4 (has reset pin)
    //[24:16]	dram_rstn_x1024 = tINIT2 = 0x1 	
    //[3:0]	pre_ocd_x32 = 0x0     
    mwl(DDR3_TOP_CTRL_BASE+0x000000d4, 0x00010000); 

    //INIT2
    //[15:8]	idle_after_reset_x32 (lpddr2 only)
    //
    mwl(DDR3_TOP_CTRL_BASE+0x000000d8, 0x00000000); 

    //INIT3, {MR1, MR2}
    //[31:16]	MR1
    //          [7]	RPST (RD Post-Amble Length) = 0b
    //          [6:4]	nWR(AP) = 101b
    //          [3]	RD-PRE = 0b
    //          [2]	WR-PRE = 1b
    //          [1:0]	BL = 00b
    //          = 01010100b = 0x54
    //[15:0]	MR2
    //		[7]	WR Lev = 0b
    //		[6]	WLS = 0b (setA)
    //		[5:3]	WL = 101b
    //		[2:0]	RL = 101b
    //		= 00101101b = 0x2D					      
    // mwl(DDR3_TOP_CTRL_BASE+0x000000dc, 0x00640036);  // 1866
    mwl(DDR3_TOP_CTRL_BASE+0x000000dc, 0x0054002D);  // 1600
    // mwl(DDR3_TOP_CTRL_BASE + INIT3, 0x00540024);  // 1200
    // mwl(DDR3_TOP_CTRL_BASE+0x000000dc, 0x0054001b);     // 1066

    //INIT4, {MR3, MR13}
    //[31:16]	MR3{DBI_WR,DBI_RD,PDDS[2:0],PPRP,WR_PST,PU-CAL} = {00110001} = 0x31
    //		[7]	DBI-WR = 0b
    //		[6]	DBI-RD =0b
    //		[5:3]	PDDS = 110b
    //		[2]	PPRP = 0b
    //		[1]	WR PST = 0b
    //		[0]	PU-CAL = 1b
    //		= 00110001 = 0x31
    //[15:0]	MR13{FSP-OP,FSP-WR,DMD,RRO,VRCG,CRO,EPR,CBT} = {00000000} = 0x00
    //		[7]	FSP-OP = 0b
    //		[6]	FSP-WR = 0b
    //		[5]	DMD = 0b
    //		[4]	RRO = 0b
    //		[3]	VRCG = 0b
    //		[2]	VRO = 0b
    //		[1]	RPT = 0b
    //		[0]	CBT = 0b
    //		= 00000000b = 0x00
    mwl(DDR3_TOP_CTRL_BASE+0x000000e0, 0x00310000); 						      

    //INIT5, {tZQINIT x32, tINIT5 x1024} 
    //[23:16]	dev_zqinit_x32 = (only support DDR3/4 LPDDR2/3) = 0x10
    //[9:0]	max_auto_init_x1024 = (only support LDPPR2/3) = 0x0 
    mwl(DDR3_TOP_CTRL_BASE+0x000000e4, 0x00100002); 

    //INIT6, {MR11, MR12}
    //[31:16]	MR11
    //		[7]	RFU = 0b
    //		[6:4]	CA ODT = 100b
    //		[3]	RFU = 0b
    //		[2:0]	DQ ODT = 100b
    //		= 01000100b = 0x44
    //[15:0]	MR12
    //		[7]	RFU = 0b
    //		[6]	VR-CA = 1b
    //		[5:0]	VREF(CA) = 011100b
    //		[5:0]	VREF(CA) = 001101b
    //		= 00011100b = 0x4d
    mwl(DDR3_TOP_CTRL_BASE+0x000000e8, 0x0044004d);  

    //INIT7, {MR22, MR14}   
    //[31:16]	MR22{RFU,ODTD-CA,ODTE-CS,ODTE-CK,SoC ODT[2:0]} = {00000000} = 0x00
    //		[7:6]	Reserved = 00b
    //		[5]	ODTD-CA = 0b
    //		[4]	ODTE-CS = 0b
    //		[3]	ODTE-CK = 0b
    //		[2:0]	SoC ODT = 100b
    //		= 00000100b = 0x04	
    //		= 00011000b = 0x18	
    //[15:0]	MR14{RFU,VR-DQ,VREF(DQ)[5:0]} = {00011001} =0x19
    //		[7]	RFU = 0b
    //		[6]     VR-DQ = 1b
    //		[5:0]	VREF(DQ) = 011100b
    //		[5:0]	VREF(DQ) = 001111b
    //		= 00011100b = 0x4F
    mwl(DDR3_TOP_CTRL_BASE+0x000000ec, 0x0018004F);  

    //DRAMTMG0
    //[30:24]	tWR2PRE = WL+BL/2+tWR = 14 + 16/2 + 29 = 51 => 51/2 = 0x1A
    //[21:16]	tFAW = 40ns = 64 => 64/2 = 32 = 0x20
    //[14:8]	tRASmax_x1024 = 70200ns = (112320t/1024 -1)/2 = 54 = 0x36
    //[5:0]	tRASmin = 42ns = 34 = 0x22 
    // mwl(DDR3_TOP_CTRL_BASE+0x00000100, 0x1A203622);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000100, 0x00003600 | \
        (div_round_up(nWL + (BL / 2) + nWR, 2) << 24) | \
        (div_round_up(nFAW, 2) << 16) | \
        (div_round_up(nRAS, 2)));

    //DRAMTMG1
    //[20:16]	tXP =   6 = 0x6
    //[13:8]	tRD2PRE = 6 = 0x06
    // //[6:0]	tRC = (ap)51, (pb)48 = 0x33(ab)
    // mwl(DDR3_TOP_CTRL_BASE+0x00000104, 0x00060633);
    // mwl(DDR3_TOP_CTRL_BASE+0x00000104, 0x00060630);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000104, 0x00000600 | (div_round_up(nXP, 2) << 16) | (div_round_up(nRC, 2)));

    //DRAMTMG2
    //[29:24]	WL = (set A)14, (set B) 26 = 14/2(set A) = 0x7
    //[21:16]	RL = (No DBI)28, (w/ DBI) 32  = 28/2(No DBI) = 0xE
    //[13:8]	rd2wr /wODT = RL+BL/2+tDQSCKmax+RD_POSTAMBLE-ODTLon-tODTon(min)+1 => use this
    //[13:8]	rd2wr /woODT = RL+BL/2+tDQSCKmax+WR_PREAMBLE+PD_POSAMBLE-WL = 28 +8 + 3 + 2 + 1.5 - 14 = 28.5 => 28.5 /2 = 0xF
    //[5:0]	wr2rd = WL+BL/2+tWTR+1 = roundup((16+8+16+1)/2) = 21 = 0x15
#ifdef DEBUG_800_MHZ
    // mwl(DDR3_TOP_CTRL_BASE+0x00000108, 0x04071115);  //1600
    mwl(DDR3_TOP_CTRL_BASE+0x00000108, 0x050a1115);  //800
#else
    // mwl(DDR3_TOP_CTRL_BASE+0x00000108, 0x08101115);  //kenny, 1866
    // mwl(DDR3_TOP_CTRL_BASE+0x00000108, 0x070E1315);  //kenny, 1600
    mwl(DDR3_TOP_CTRL_BASE + 0x00000108, \
      (div_round_up(nWL, 2) << 24) | \
      (div_round_up(nRL, 2) << 16) | \
      (div_round_up(nRL + (BL / 2) + 3 + 2 - 6 - t2n(1500) + 1, 2) << 8) | \
      div_round_up(nWL + (BL / 2) + nWTR + 1, 2));
#endif

    //DRAMTMG3
    //[29:20]	tMRW = 16/2 = 0x8
    //[17:12]	tMRD = 23/2 = 0xC
    //[9:0]	tMOD = LPDDR4 (NA) = 0
    // mwl(DDR3_TOP_CTRL_BASE+0x0000010c, 0x00C0c000);
    mwl(DDR3_TOP_CTRL_BASE + 0x0000010c, (div_round_up(nMRW, 2) << 20) | ((div_round_up(nMRD, 2) << 12)));

    mwl(DDR3_TOP_CTRL_BASE+0x000001b4, 0x0000170a);

    //DRAMTMG4
    //[28:24]	tRCD = 28.8/2 = 0xF
    //[19:16]	tCCD = 8/2 = 0x4
    //[11:8]	tRRD = 16/2 = 0x8
    //[4:0]	tRP = 33.6/2 = 0x11
    // mwl(DDR3_TOP_CTRL_BASE+0x00000110, 0x0F040811);
    // mwl(DDR3_TOP_CTRL_BASE+0x00000110, 0x0E040810);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000110, (div_round_up(nRCD, 2) << 24) | (div_round_up(nCCD, 2) << 16) | (div_round_up(nRRD, 2) << 8) | div_round_up(nRP, 2));


    //DRAMTMG5
    //[27:24]	tCKSRX = tCKCKEH = 3/2 = 0x2
    //[23:16]	tCKSRE = tCKELCK = 8/2 = 0x4
    //[15:8]	tCKESR = max(tCKE,tSR) = max(12,24) = 24/2 = 0xC
    //[4:0]	tCKE = 12/2 = 0x6
    mwl(DDR3_TOP_CTRL_BASE+0x00000114, 0x02040c06); 

    //DRAMTMG6
    //[27:24]	tCKDPDE = LPDDR4(NA) = 0x2
    //[19:16]	tCKDPDX = LPDDR4(NA) = 0x2
    //[3:0]	tCKCSX = tXP+2 = 12+2 = 14/2 = 0x7
    mwl(DDR3_TOP_CTRL_BASE+0x00000118, 0x01010007);

    //DRAMTMG7
    //[11:8]	tCKPDE = tCKELCK = 8/2 = 0x4
    //[3:0]	tCKPDX = tCKCKEH = 3/2 = 0x2
    mwl(DDR3_TOP_CTRL_BASE+0x0000011c, 0x00000402); 

    //DRAMTMG8 DDR2/3/4 only
    //DRAMTMG9 DDR4 only
    //DRAMTMG10 DDR4 only
    //DRAMTMG11 DDR4 only

    //DRAMTMG12
    //[29:24]	tWR_MPR = LPDDR4 (NA) = 0x1a
    //[17:16]	tCMDCKE = 3/2 = 0x2
    //[4:0]	tMRD_PDA = LPDDR4(NA) = 0x10
    // mwl(DDR3_TOP_CTRL_BASE+0x00000130, 0x1a020010);
    mwl(DDR3_TOP_CTRL_BASE + 0x00000130, 0x00020010 | (div_round_up(nWR, 2) << 24));

    //DRAMTMG13
    //[30:24]	ODTLoff = 26/2 = 0xD
    //[21:16]	tCCDMW = 4*tCCD = 32/2 = 0x10
    //[2:0]	tPPD = 4/2 = 0x2
    mwl(DDR3_TOP_CTRL_BASE+0x00000134, 0x0d100002); 

    //DRAMTMG14
    //[11:0]	tXSR = 220/2 = 0x6E
    mwl(DDR3_TOP_CTRL_BASE + DRAMTMG14, 0x000000DB);

    //DRAMTMG15 DDR3/4 only
    //DRAMTMG16 DDR4 3DS only
    
    //DRAMTMG17 HWFFC enable only

    //---------------------------------------------------------------------------
    //RFSHTMG_HET  DDR3/4 only
    //MRAMTMG0 ~ MRAMTMG9 DDR4_MRAM only

    //---------------------------------------------------------------------------
    //ZQ Control register
    //ZQCTL0
    //[31]	dis_auto_zq = 0b
    //[30]	dis_srx_zqcl = 0b
    //[29]	zq_resistor_shared = 0b
    //[28]	dis_mpsmx_zqcl = =0b
    //[26:16]	t_zq_long_nop = tZACAL/2 = 800 = 0x320
    //[9:0]	t_zq_share_nop = tZQLAT/2 = 24 = 0x18
    //          = 0x03200018


 #ifdef EN_TRAIN  
    mwl(DDR3_TOP_CTRL_BASE+0x00000180, 0xc3200018);   // kenny2

#else
    //mwl(DDR3_TOP_CTRL_BASE+0x00000180, 0x03200018);
    mwl(DDR3_TOP_CTRL_BASE+0x00000180, 0xC3200018);
#endif




    //ZQCTL1
    //[29:20]	t_zq_reset_nop = tZQReset/2 = 40 = 0x28
    //[19:0]	t_zq_short_interval_x1024 = 0x100 (defulat, It can be fine turn)
    //          = 0x02800100
    mwl(DDR3_TOP_CTRL_BASE+0x00000184, 0x02800100); 

    //ZQCTL2
    //[0]	zq_reset, setting ZQ resetion operaions.

    //ZQSTAT RO
    //[0]	zq_reset_busy, 1: Indicates that ZQ reset operatio is in progress

    //---------------------/---------------------------------------------------------------------------------
    // 0909 add tZQCAL setting to fix post-sim error by Jaron
    //rdata_out = mrl(DDR3_TOP_CTRL_BASE+0x00000180,data);
    //mwl(DDR3_TOP_CTRL_BASE+0x00000180, ( rdata_out | 0x02590013));//bit[0] Set dfi_init_complete_en = 0 
    //

    //-------------------------------------------------------------------------------
    //DFITMG0
    //[28:24]	dfi_t_ctrl_delay = 00011b
    //[23]	dfi_rddata_use_dfi_phy_clk = 1b 
    //[22:16]	dfi_t_rddata_en = trddata_en (reference dwc_lpddr4_multiphy_v2_pub_databook.pdf p.156)
    //		trddata_en = RL-5 + 2*(DWC_DDRPHY_PIPE_DFI_MISC-DWC_DDRPHY_PIPE_DFI_RD) = 28 - 5 = 23 = 0x17
    //[15]	dfi_wrdata_use_dfi_clk = 1b
    //[13:8]	dfi_tphy_wrdata = tphy_wrdata (reference dwc_lpddr4_multiphy_v2_pub_databook.pdf p.155)
    //          tphy_wrdata = 2 = 0x2
    //[5:0]	dfi_tphy_wrlat = tphy_wrlat
    //          tphy_wrlat = WL-5 + 2*(DWC_DDRPHY_PIPE_DFI_MISC-DWC_DDRPHY_PIPE_DFI_WR) = 14 - 5 = 9 = 0x9
    //		= 0x03978209 	
  #ifdef EN_TRAIN
#ifdef DEBUG_800_MHZ
    // mwl(DDR3_TOP_CTRL_BASE+0x00000190, 0x04898204);//1600
    mwl(DDR3_TOP_CTRL_BASE+0x00000190, 0x048f8206);//800
#else
    // mwl(DDR3_TOP_CTRL_BASE+0x00000190, 0x049b820c);//1866, nanya
    mwl(DDR3_TOP_CTRL_BASE+0x00000190, 0x0497820a);//1600
    // mwl(DDR3_TOP_CTRL_BASE + DFITMG0, 0x04808207 | ((nRL - << 16) | (nWL));//1200
#endif
  #else
    mwl(DDR3_TOP_CTRL_BASE+0x00000190, 0x0497820a);
  #endif
    
    //////////////////////////////////////////////////////////
    //DFITMG1
    //[31:28]	dfi_t_cmd_lat  (DDR4 only) = 0x0
    //[25:24]	dfi_t_parin_lat = (DDR3/4 only) = 0x0
    //[20:16]	dfi_t_wrdata_delay = 0x0
    //[12:8]	dfi_t_dram_clk_disable =0x4
    //[4:0]	dfi_t_dram_clk_enable = 0x4
    //		= 0x00000404 (default)
    //////////////////////////////////////////////////////////

    //DFIUPD1
    mwl(DDR3_TOP_CTRL_BASE+0x000001a4, 0x00140014);

#ifdef TRAIN_2ND_FREQ
#ifdef  EN_TRAIN //DDR_ENABLE_FSP
    mwl(DDR3_TOP_CTRL_BASE+  SWCTL, 0x00000000);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DERATEEN, 0x0000001);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DERATEINT, 0xd0000000);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + RFSHCTL0, 0x80210030);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + RFSHTMG,  0x0049006d);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + INIT3,    0x00440024);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + INIT4,    0x00310000);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + INIT6,    0x0044004d);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + INIT7,    0x0018004F);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG0, 0x19203622);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG1, 0x00060633);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG2, 0x060c1015);

    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG3, 0x0080c000);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG4, 0x0F040811);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG5, 0x02040c06);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG6, 0x01010007);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG7, 0x00000402);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG12, 0x1a020010);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG13, 0x0d100002);
    mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG14, 0x0000006E);
  //  mwl(DDR3_TOP_CTRL_BASE+ 0x2000 + DRAMTMG17, 0x);

    mwl(DDR3_TOP_CTRL_BASE+ ZQCTL0 + 0x2000, 0xc3200018); 
    mwl(DDR3_TOP_CTRL_BASE+ DFITMG0 + 0x2000,  0x04938208);
    mwl(DDR3_TOP_CTRL_BASE+ SWCTL,  0x00000001);

    do {
      mrl(DDR3_TOP_CTRL_BASE + SWSTAT,data);
    } while((data & 0x00000001) == 0);
#endif
#endif





//Address Mapping
//--------------------------------------------------
//2Gb LPDDR4
//Row[13:0], BA[2:0], Col[9:0]
//Col[9:0] 	= hif addr[9:0] 	= axi addr[11:2]
//BA[2:0]  	= hif addr[12:10]	= axi addr[14:12]
//Row[13:0]	= hif addr[26:13]	= axi addr[28:15]
    //ADDRMAP0 -- Dont used
    //[20:16]	addrmap_dch_bit0 = 31 = 0x1F
    //[12:8]	addrmap_cs_bit1 = 31 = 0x1F
    //[4:0]	addrmap_cs_bit0 = 31 = 0x1F
    //          = 0x001F1F1F
//    mwl(DDR3_TOP_CTRL_BASE+0x00000200, 0x001F1F1F);
    
    //ADDRMAP1
    //[21:16]	addrmap_bank_b2 = 10 - 2(internal base:2) = 8 = 0x8
    //[13:8]	addrmap_bank_b1 = 11 - 3(internal base:3) = 0 = 0x8
    //[5:0]	addrmap_bank_b0 = 12 - 4(internal base:4) = 8 = 0x8
    //		= 0x00080808
//    

#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000204, 0x00070707);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x00000204, 0x00080808);
#endif


    //ADDRMAP2
    //[27:24]	addrmap_col_b5 = 5 - 5(internal base:5) = 0
    //[19:16]	addrmap_col_b4 = 4 - 4 = 0
    //[12:8]	addrmap_col_b3 = 3 - 3 = 0
    //[3:0]	addrmap_col_b2 = 2 - 2 = 0
    //		= 0x00000000
//    
#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000208, 0x00000000);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x00000208, 0x00000000);
#endif

    //ADDRMAP3
    //[27:24]	addrmap_col_b9 = 9 - 9(internal base:5) = 0
    //[19:16]	addrmap_col_b8 = 8 - 8 = 0
    //[12:8]	addrmap_col_b7 = 7 - 7 = 0
    //[3:0]	addrmap_col_b6 = 6 - 6 = 0
    //		= 0x00000000
//    mwl(DDR3_TOP_CTRL_BASE+0x0000020C, 0x00000000);

#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x0000020C, 0x1f000000);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x0000020C, 0x00000000);
#endif

    //ADDRMAP4
    //[31]	col_addr_shift = 0
    //[12:8]	addrmap_col_b11 = 31 = 0x1F
    //[4:0]	addrmap_col_b10 = 31 = 0x1F
    //          = 0x00001F1F
    mwl(DDR3_TOP_CTRL_BASE+0x00000210, 0x00001F1F);

    //ADDRMAP5
    //[27:24]	addrmap_row_b11 = 24 - 17 = 7 = 0x7
    //[19:16]	addrmap_row_b2_10 = 15 - 8 = 7 = 0x7
    //[11:8]	addrmap_row_b1 = 14 - 7 = 7 = 0x7
    //[3:0]	addrmap_row_b0 = 13 - 6 = 7 = 0x7
    //          = 0x07070707


#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000214, 0x06060606);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x00000214, 0x07070707);
#endif

    //ADDRMAP6
    //[31:29]	lpddr34_3gb_6bg_12bg = 0
    //[27:24]	addrmap_row_b15 = 15 = 0xF
    //[19:16]	addrmap_row_b14 = 15 = 0xF
    //[11:8]	addrmap_row_b13 = 26 - 19 = 7 = 0x7
    //[3:0]	addrmap_row_b12 = 25 - 18 = 7 = 0x7
    //          = 0x0F0F0707
//    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x0f0f0f07);
#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x0f0f0606);	// 256 MB 2Gb
#else
    mwl(DDR3_TOP_CTRL_BASE+0x00000218, 0x07070707);	// 2048 MB 16Gb
#endif


    //ADDRMAP7
    //[11:8]	addrmap_row_b17 = 15 = 0xF
    //[3:0]	addrmpa_row_b16 = 16 = 0xF
    //          = 0x00000F0F
    mwl(DDR3_TOP_CTRL_BASE+0x0000021c, 0x00000F0F);

    //ADDRMAP8
    //[13:8]	addrmap_bg_b1 = 63 = 0x3F
    //[5:0]	addrmap_bg_b0 = 63 = 0x3F
    //          = 0x00003F3F
//    mwl(DDR3_TOP_CTRL_BASE+0x00000220, 0x00003F3F);

    //ADDRMAP9
    //[27:24]	addrmap_row_b5 = 18 - 11 = 7 = 0x7
    //[19:16]	addrmap_row_b4 = 17 - 10 = 7 = 0x7
    //[11:8]	addrmap_row_b3 = 16 - 9 = 7 = 0x7
    //[3:0]	addrmpa_row_b2 = 15 - 8 = 7 = 0x7
    //          = 0x07070707
    mwl(DDR3_TOP_CTRL_BASE+0x00000224, 0x07070707);
   
    //ADDRMAP10 
    //[27:24]	addrmap_row_b9 = 22 - 15 = 7 
    //[19:16]	addrmap_row_b8 = 21 - 14 = 7
    //[11:8]	addrmap_row_b7 = 20 - 13 = 7
    //[3:0]	addrmap_row_b6 = 19 - 12 = 7
    //          = 0x07070707
//    mwl(DDR3_TOP_CTRL_BASE+0x00000228, 0x07070707);
#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x00000228, 0x06060606);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x00000228, 0x07070707);
#endif

    //ADDRMAP11
    //[20:16]	addrmap_cid_b1 = 31 = 0x1F
    //[12:8]	addrmap_cid_b0 = 31 = 0x1F
    //[3:0]	addrmap_row_b10 = 23 - 16 = 7 = 0x7
    //          = 0x001F1F07
//    mwl(DDR3_TOP_CTRL_BASE+0x0000022C, 0x001F1F07);
#ifdef LPDDR4_DATA_BUS_16
    mwl(DDR3_TOP_CTRL_BASE+0x0000022C, 0x001F1F06);
#else
    mwl(DDR3_TOP_CTRL_BASE+0x0000022C, 0x001F1F07);
#endif


//---------------------------------------------------------------------------

    //ODTCFG (Dont support for LPDDR4)
    //ODTMAP (default value)



//---------------------------------------------------------------------------
//UMCTL2_MP registe
//---------------------------------------------------------------------------
    //PCCFG    
    //[13:12]	dch_density_ratio = 00b
    //[8]	bl_exp_mode = 0b
    //[4]	pagematch_limit = 0b
    //[0]	go2critical_en = 0b
    //          = 0x00000000

    //PCFGR_n , n=0, n<=15
    //[23:20]	rrb_lock_threshold
    //[16]	rdwr_ordered_en
    //[14]	rd_port_pagematch_en
    //[13]	rd_port_urgent_en
    //[12]	rd_port_aging_en
    //[11]	read_reorder_bypass_en
    //[9:0]	rd_port_priority

    //PCFGW_n , n=0, n<=15
    //[14]	wr_port_pagematch_en
    //[13]	wr_port_urgent_en
    //[12]	wr_port_aging_en
    //[9:0]	wr_port_priority


    //PCFGC_n , n=0, n<=15
    //[1:0]	ahb_}anness

    //PCFGIDMASKCH m_n (for m,n = 0; m,n <= 15)
    //[x:0]	id_mask

    //PCFGIDVALUECH m_n (for m,n = 0; m,n <= 15)
    //[x:0]	id_value

    // sw_done for programming quasi_3 registers
    // writel(0x00000000, DDR3_TOP_CTRL_BASE + 0x00000320);
    // while ((readl(DDR3_TOP_CTRL_BASE + 0x00000324) & 0x1) == 1);

    // data = 10; //
    // writel( 0x03FF03FF, DDR3_TOP_CTRL_BASE + 0x00000498 + (0xb0 * data));
    // writel( 0x03FF03FF, DDR3_TOP_CTRL_BASE + 0x000004A0 + (0xb0 * data));

    // data = 12; //CDCE
    // writel( 0x03FF03FF, DDR3_TOP_CTRL_BASE + 0x00000498 + (0xb0 * data));
    // writel( 0x03FF03FF, DDR3_TOP_CTRL_BASE + 0x000004A0 + (0xb0 * data));

    
    // writel(0x00000001, DDR3_TOP_CTRL_BASE + 0x00000320);
    // while ((readl(DDR3_TOP_CTRL_BASE + 0x00000324) & 0x1) == 0);

    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 6));
    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 10));
    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 12));
    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 13));
    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 14));
    writel( 0x00080008, VPL_DDRSDMC_MMR_BASE + 0x000000DC + (0x4 * 15));

    //PCTRL_n (for n = 0; n <= 15)
    //Offset :0x490 + 0xb0*n
    //[0]	port_en
    mwl(DDR3_TOP_CTRL_BASE+0x00000490, 0x00000001);//enable port 0 
    mwl(DDR3_TOP_CTRL_BASE+0x00000540, 0x00000001);//enable port 1 
    mwl(DDR3_TOP_CTRL_BASE+0x000005f0, 0x00000001);//enable port 2 
    mwl(DDR3_TOP_CTRL_BASE+0x000006a0, 0x00000001);//enable port 3 
    mwl(DDR3_TOP_CTRL_BASE+0x00000750, 0x00000001);//enable port 4 
    mwl(DDR3_TOP_CTRL_BASE+0x00000800, 0x00000001);//enable port 5 
    mwl(DDR3_TOP_CTRL_BASE+0x000008b0, 0x00000001);//enable port 6 
    mwl(DDR3_TOP_CTRL_BASE+0x00000960, 0x00000001);//enable port 7 
    mwl(DDR3_TOP_CTRL_BASE+0x00000a10, 0x00000001);//enable port 8 
    mwl(DDR3_TOP_CTRL_BASE+0x00000ac0, 0x00000001);//enable port 9 
    mwl(DDR3_TOP_CTRL_BASE+0x00000b70, 0x00000001);//enable port 10 
    mwl(DDR3_TOP_CTRL_BASE+0x00000c20, 0x00000001);//enable port 11
    mwl(DDR3_TOP_CTRL_BASE+0x00000cd0, 0x00000001);//enable port 12
    mwl(DDR3_TOP_CTRL_BASE+0x00000d80, 0x00000001);//enable port 13
    mwl(DDR3_TOP_CTRL_BASE+0x00000e30, 0x00000001);//enable port 14
    mwl(DDR3_TOP_CTRL_BASE+0x00000ee0, 0x00000001);//enable port 15
}

#define SZ_32				U(0x00000020)
#define SZ_64				U(0x00000040)
#define SZ_128				U(0x00000080)
#define SZ_256				U(0x00000100)
#define SZ_512				U(0x00000200)

#define SZ_1K				U(0x00000400)
#define SZ_2K				U(0x00000800)
#define SZ_4K				U(0x00001000)
#define SZ_8K				U(0x00002000)
#define SZ_16K				U(0x00004000)
#define SZ_32K				U(0x00008000)
#define SZ_64K				U(0x00010000)
#define SZ_128K				U(0x00020000)
#define SZ_256K				U(0x00040000)
#define SZ_512K				U(0x00080000)

#define SZ_1M				U(0x00100000)
#define SZ_2M				U(0x00200000)
#define SZ_4M				U(0x00400000)
#define SZ_8M				U(0x00800000)
#define SZ_16M				U(0x01000000)
#define SZ_32M				U(0x02000000)
#define SZ_64M				U(0x04000000)
#define SZ_128M				U(0x08000000)
#define SZ_256M				U(0x10000000)
#define SZ_512M				U(0x20000000)

#define SZ_1G				U(0x40000000)
#define SZ_2G				U(0x80000000)

#define MG_0 0x82451282

typedef unsigned int  ulong;
typedef volatile unsigned int  vu_long;
static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr, vu_long *dummy);
int mtest(void);

#define SYNOPSIS_BUS_MAPPING
static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
			  vu_long *dummy)
{
	vu_long *addr;
	ulong errs = 0;
	ulong val, readback;
	int j, bytelane;
	vu_long offset;
	vu_long test_offset;
	vu_long pattern;
	vu_long temp;
	vu_long anti_pattern;
	vu_long num_words;
	static const ulong bitpattern[] = {
		0x00000001,	/* single bit */
		0x00000003,	/* two adjacent bits */
		0x00000007,	/* three adjacent bits */
		0x0000000F,	/* four adjacent bits */
		0x00000005,	/* two non-adjacent bits */
		0x00000015,	/* three non-adjacent bits */
		0x00000055,	/* four non-adjacent bits */
		0xaaaaaaaa,	/* alternating 1/0 */
	};

	num_words = (end_addr - start_addr) / sizeof(vu_long);

	/*
	 * Data line test: write a pattern to the first
	 * location, write the 1's complement to a 'parking'
	 * address (changes the state of the data bus so a
	 * floating bus doesn't give a false OK), and then
	 * read the value back. Note that we read it back
	 * into a variable because the next time we read it,
	 * it might be right (been there, tough to explain to
	 * the quality guys why it prints a failure when the
	 * "is" and "should be" are obviously the same in the
	 * error message).
	 *
	 * Rather than exhaustively testing, we test some
	 * patterns by shifting '1' bits through a field of
	 * '0's and '0' bits through a field of '1's (i.e.
	 * pattern and ~pattern).
	 */
	addr = buf;
	for (j = 0; j < sizeof(bitpattern) / sizeof(bitpattern[0]); j++) {
		val = bitpattern[j];
		for (; val != 0; val <<= 1) {

			#ifdef SYNOPSIS_BUS_MAPPING
			for (bytelane = 0; bytelane <= 3; bytelane++) {
				addr = buf + bytelane;
			#endif
				*addr = val;
				*dummy  = ~val; /* clear the test data off the bus */
				readback = *addr;
				if (readback != val) {
					ERROR("FAILURE (data line): "
						"expected %08x, actual %08x\n",
							val, readback);
					errs++;
				}
				*addr  = ~val;
				*dummy  = val;
				readback = *addr;
				if (readback != ~val) {
					ERROR("FAILURE (data line): "
						"Is %08x, should be %08x\n",
							readback, ~val);
					errs++;
				}
			#ifdef SYNOPSIS_BUS_MAPPING
			}
			#endif
		}
	}

	/*
	 * Based on code whose Original Author and Copyright
	 * information follows: Copyright (c) 1998 by Michael
	 * Barr. This software is placed into the public
	 * domain and may be used for any purpose. However,
	 * this notice must not be changed or removed and no
	 * warranty is either expressed or implied by its
	 * publication or distribution.
	 */

	/*
	* Address line test

	 * Description: Test the address bus wiring in a
	 *              memory region by performing a walking
	 *              1's test on the relevant bits of the
	 *              address and checking for aliasing.
	 *              This test will find single-bit
	 *              address failures such as stuck-high,
	 *              stuck-low, and shorted pins. The base
	 *              address and size of the region are
	 *              selected by the caller.

	 * Notes:	For best results, the selected base
	 *              address should have enough LSB 0's to
	 *              guarantee single address bit changes.
	 *              For example, to test a 64-Kbyte
	 *              region, select a base address on a
	 *              64-Kbyte boundary. Also, select the
	 *              region size as a power-of-two if at
	 *              all possible.
	 *
	 * Returns:     0 if the test succeeds, 1 if the test fails.
	 */
	pattern = (vu_long) 0xaa55aa55;		// cpu <> dq mapping
	anti_pattern = (vu_long) 0x55aa55aa;	// single word(32bit)only test 1 bytelane,

	//debug("%s:%d: length = 0x%.8x\n", __func__, __LINE__, num_words);
	/*
	 * Write the default pattern at each of the
	 * power-of-two offsets.
	 */
	for (offset = 1; offset < num_words; offset <<= 1)
		addr[offset] = pattern;

	/*
	 * Check for address bits stuck high.
	 */
	test_offset = 0;
	addr[test_offset] = anti_pattern;

	for (offset = 1; offset < num_words; offset <<= 1) {
		temp = addr[offset];
		if (temp != pattern) {
			ERROR("\nFAILURE: Address bit stuck high @ 0x%.8x:"
				" expected 0x%.8x, actual 0x%.8x\n",
				start_addr + offset*(ulong)sizeof(vu_long),
				pattern, temp);
			errs++;
		}/*
		else
			printf("\nPASS: Address bit raise high @ 0x%.8x",
				start_addr + offset*sizeof(vu_long));*/
	}
	addr[test_offset] = pattern;

	/*
	 * Check for addr bits stuck low or shorted.
	 */
	for (test_offset = 1; test_offset < num_words; test_offset <<= 1) {
		addr[test_offset] = anti_pattern;

		for (offset = 1; offset < num_words; offset <<= 1) {
			temp = addr[offset];
			if ((temp != pattern) && (offset != test_offset)) {
				ERROR("\nFAILURE: Address bit stuck low or"
					" shorted @ 0x%.8x: expected 0x%.8x,"
					" actual 0x%.8x\n",
					start_addr + offset*(ulong)sizeof(vu_long),
					pattern, temp);
				errs++;
			}
		}
		addr[test_offset] = pattern;
	}

	return errs;
}

#define TEST_OFFSET (0x20)
unsigned long detect_size(void)
{
        unsigned int * addr_gb[] = { (unsigned int*)(0 + TEST_OFFSET), 
                              (unsigned int*)(SZ_64M + TEST_OFFSET),
                               (unsigned int*)(SZ_128M + TEST_OFFSET),
                                (unsigned int*)(SZ_256M + TEST_OFFSET),
                                 (unsigned int*)(SZ_512M + TEST_OFFSET),
                                  (unsigned int*)(SZ_1G + TEST_OFFSET),
                                   (unsigned int*)(SZ_2G + TEST_OFFSET)};
        unsigned int i = 0;
        unsigned int val = 0;

        INFO("detect_size....");
        *(addr_gb[0]) = MG_0;
        INFO("*(addr_gb[0]):%x\n", *(addr_gb[0]));
        for ( i = 1; i < sizeof(addr_gb)/sizeof(unsigned long); i++ )
        {
                *(addr_gb[i]) = (unsigned long)addr_gb[i];
                val = *(addr_gb[i]);
                INFO("*(addr_gb[%d]):%x\n", i, val);

                if ( *(addr_gb[0]) != MG_0)
                {
                        INFO("Overlapping detected,i:%d, val:0x%x, 0x%x\n", i, val, *(addr_gb[0]) );
                        return val ;
                }
        }

        INFO("2GBytes.\n");
        return SZ_2G;
}

#define TEST_START_ADDR SZ_32
#define TEST_END_ADDR 	SZ_256M
int mtest(void)
{
        ulong skeleton = 0;
        ulong *dummy = &skeleton;
	ulong errs = 0; /* number of errors, or -1 if interrupted */
        unsigned int iteration = 0;
        unsigned int iteration_limit = 1;
	      unsigned int size = detect_size();

        for (iteration = 0;
                        !iteration_limit || iteration < iteration_limit;
                        iteration++) {
                INFO("Iteration: %6d/%6d\r", iteration + 1, iteration_limit);
                errs = mem_test_alt((void*)TEST_START_ADDR, TEST_START_ADDR, size, dummy);

                if (errs == -1UL)
                        break;
        }

	return errs;
}

